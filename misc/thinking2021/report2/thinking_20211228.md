start from CVE that cannot be exploited by SLAKE



#### CVE-2017-2636

- double-free kmalloc-8K, not readable/writable
- in wild exp: exploit by overwritting `skb_shared_info.destructor_arg`.Since the double-free vul does not provide overwrite primitive, we have to do the overwrite by heap spray with syscall `add_key()`
- https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-2636

this CVE is disccussed in evaluation part of SLAKE, the exploitation is failed simply  due to SLAKE did not find such object that can be allocated to kmalloc-8K

> how to find as many objects as possible, by loosing the constraint and to a certain extent, give up pricision



> double free often requires heap spray, SLAKE only found 4 heap spray objects. Finding more spray objects is neccessary
>
> - directly write user data to kernel heap: control a memory region, once. e.g. copy_from_user()
> - write user data to kernel heap in multi steps
> - some field of kernel objects on the heap is controllable by user (if such knowledge is sufficient enough, it is almost as powerful as control a memory region for in many cases we only need to overwrite part of the the memory region, not the whole region)





#### CVE-2014-2851

- UAF kmalloc-192, the first 4 bytes writable(by overflow an int variable, so technically we can overwrite it multi times)
- in wild exp: when the controlled chunk is inserted to the SLAB free list, overwrite the pointer to next free chunk, make it point to user space where we can directly control. Then allocate any kernel objects that contains function pointer to achive RIP hijacking
- https://duasynt.com/blog/cve-2014-2851-group_info-use-after-free-exploitation
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2851

Included in evaluation part of SLAKE, same reason as CVE-2017-2636. The exploitation is unfeasible when SMAP/SMEP/PTI is enabled



> - when taking kernel protection machanisms into consideration, simple and direct exploitation is almost impossible(RIP hijacking). But knowing other things that can be done with the vul primitive can also be meaningful(cause a local DoS as an unprivilledge user)
> - SLAKE says it failed to find an object to be allocated into target kmalloc cache(kmalloc-192), not to mention RIP hijacking by a 4 bytes overwrite primitive

 

#### CVE-2017-1000112

- OOB: OOB write in `struct skb_buff`.
- in wild exp: overwrite a kernel object `skb_shared_info`, which lies adjacent to the vul `skb_buff`. By overwriting a function pointer inside it an attacker can get a RIP hijacking primitive
- https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-1000112/poc.c
- https://www.openwall.com/lists/oss-security/2017/08/13/1
- discussed by SLAKE: SLAKE says that the overwrite happens inside of the vul object itself, completely not how SLAKE works

> the exploitation is rather simple in a certain way, there is a function pointer around the OOB region, but SLAKE can not find such paradigm
>
> if we have a knowledge database that include exploitable execution path around `skb_shared_info`, it can help with the exploit or to some extend inspire the exploit





#### CVE-2017-17052

- UAF: `mm_struct->exe_file` can point to a freed chunk in some execution path. 
- `mm_struct->exe_file` is a pointer to a `struct file` object, which is a ref to `/proc/<pid>/exe` which is a symbolic link to the executable file that is being runned by current process
- the UAF region is not a general one, but a specific field of a kernel object and the field is not a function pointer or something likely to be exploitable.The vul is inside the core part of linux kernel and no special kernel config is needed, and the vul affect kernel before 4.12.10
- https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h#L543
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-17052

> no known exp yet. If we can find a proper spray object the vul can give us complete control over a `struct file` object, looks promissing



> It seems that challenges in exploiting heap-based vul can be reducted to lack of knowledge to exploitable kernel objects and its execution path



#### CVE-2018-10840

- OOB: heap overflow in `ext4_xattr_set_entry()`. The overflow happens inside of an `ext4_xattr_search` struct, the content and destination are both uncontrollable
- https://elixir.bootlin.com/linux/v4.15/source/fs/ext4/xattr.c#L1671
- https://bugzilla.kernel.org/show_bug.cgi?id=199347

> unlikely to be exploited, need further inspection into execution path around `struct ext4_xattr_search`



#### CVE-2018-12714

- OOB: out-of-bound write, no detail analysis found, no known exp





#### CVE-2018-16880

- OOB: oob write on kmalloc-8, may cause memory corruption and panic, no known exp



#### CVE-2018-17182

- UAF: 
- https://googleprojectzero.blogspot.com/2018/09/a-cache-invalidation-bug-in-linux.html



#### CVE-2018-6555

- UAF:
- https://duasynt.com/slides/bevx-talk.pdf



> there is almost no such "clean" vul capability model in real world linux kernel cves, because the vul itself is always strongly related to a specific kernel object and some execution path around it. The exploitation, in many cases, have to heavlily rely on the capability of the vul (e.g. heap spray data into vulnerable object to overwrite a function pointer then invoke it through an execution path around the vulnerable object itself), for the vul usually does not allow us to write data freely to the vul region
>
>e.g.
> 
> - heap out-of-bound write/read only allow write/read to a specific struct
> - UAF does not provide primitives that let us write/read data freely to a region
> - double-free looks more promising under my exploit paradigm: the vul provide a overwrite/read primitive to a heap chunk, where we can allocate a specific kernel object into then poke around with it
>
> from this point of view, the exploitation actually relies on an interaction between the vul object and known exploitable objects(kernel object that have exploitable properties or object that can spray data into kernel heap). For a specific vul, that will need a deeper understanding of the vul object involved (e.g. function pointer inside the object, or pointer to a struct whose function pointer can be called by a syscall sequence). To exploit such vul, a systematic knowledge to every kernel object is needed. If such knowledge can be build to a database, or we can build a tool to analyze a specific kernel object in feasible time, it may greatly help with kernel heap vul exploitation.





> two things can be done as a pre-experinment
>
> - identify all structs who encloses at least one function pointer, store the struct name, function name, and function pointer offset as a database. Possibly, identify all allocation sites of these structs, find a feasible way to check if the site can be achived through some syscall.
> -  identify more heap spray object, by identifying possible controllable field of each kernel object.





#### CVE-2019-18683

- UAF: dangling pointer to a `vb2_buffer` struct, in kmalloc-1024
- in wild exp: write data to the vulnerable `vb2_buffer` memory region to overwrite a function pointer using heap spray (`setxattr()` + `userfaultfd`)

the vul itself does not provide direct write/read primitves, but the exp manages to find a function pointer in the vul struct that can be called, then find a way to spray data to the region to overwrite the function pointer.



> in previous discussions, our exploitation is confined in such a paradigm
>
> - the vul object provide read/write primitive
> - we allocate a exploitable object to the vul region then overwrite/overread some data fields using the primitive, then proceed to exploitation with execution path around the exploitable object
>
> however, there is also such a paradigm
>
> - the vul object itself provides more promissing primitives like fucntion pointer call
> - we manage to find a way to overwrite the function poiner by allocating exploitable object to the vul region (heap spray)
>
> in many cases, the UAF vul itself is too complicate to provide a clean and simple read/write primitive. 



from such point of view, the exploitation paradigm in SLAKE and ELOISE are no longer feasible. Actually, what we need is **systematic knowledge to vul kernel objects, from the perspective of exploitation**

- how the vul kernel objects are allocated (use the kernel object we allcate to exploit)
- how the data fields inside the object is controlled/affected by user land syscalls
- how the function pointers inside the object is invoked by user land syscalls
- are there other valueble operations can be done by using the object (e.g. pointers that will be passed to kfree(), pointers that will read kernel memory data to user space, an integer that will be passed to kmalloc(), ...)



#### CVE-2018-8890

- double-free: heap spray data to kernel heap to control the double-free object





## Point1

### vuls that SLAKE cannot handle

- design

  - vul does not provide clean write primitive

    > in most UAF cases, the hangling pointer is related to a specific kernel objects, which does not provide channel to transfer user space data to kernel heap (e.g CVE-2017-17052), or the control flow to manipulate the data fields is subtle(e.g. CVE-2014-2851)

  - the heap layout of the vul not manipulatable: write primitive is constraint to a specific kernel object

    > SLAKE expects the vul provides an overwrite primitive, then we allocate a exploitable kernel objects to the overwritable memory regeion to overwrite a pointer then RIP hijack. If we can only overwrite data field of a specific kernel objects, say, the OOB happens in a embedded object and will not influence the adjacent heap chunk, the pattern of SLAKE will simply not work.(e.g. CVE-2017-1000112)

- implementation

  - SLAKE failed to identify exploitable objects in the given kmalloc cache size, even in some most commonly used caches (e.g. CVE-2014-2851, SLAKE found no object in kmalloc-192)

    > sometimes we dont need to allcate a exploitable kernel object by ourself, for there may has already been objects in or around the vulnerable objects which encloses a function pointer (e.g. CVE-2017-2636, CVE-2019-18683)

  - mitigation feature always require further knowledge of kernel objects



## Point2

solve the problem: focus on kernel object itself to build a **systematic knowledge database** for every kernel struct in exploitation perspective. For each kernel struct

- identify function pointers and its offset
- identify syscalls to call the function pointers
- identify syscalls to allocate the struct
- identify syscalls to manipulate data fileds: data field add by 1, or copy_from_user
- other interesting operations (e.g. kfree(), copy_to_user) may inspire exploitation or defeat mitigation (e.g. overread primitive may help defeat KASLR or leak heap address)
- ...

store these identified sites and check how the site can be triggered by syscalls.



implementation

- compile the kernel using LLVM
- run on each module to identify structure of every kernel structs (function pointers, struct pointers, integer values, etc. store the data type along with offset)
- run on each functions and check if an instruction allocates an kernel struct, if a function pointer in kernel struct is called, if an integer value of a struct is added by 1, or if it is other interesting operations, and store those interesting sites
- after every interesting sites is identified in kernel, check how these sites can be triggered: by symbolic execution or fuzz





